<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Emotion Mirror â€” WebGPU</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --bg-void: #06060e;
            --bg-deep: #0b0b18;
            --bg-card: rgba(14, 14, 30, 0.7);
            --bg-card-hover: rgba(20, 20, 42, 0.8);
            --border-subtle: rgba(255, 255, 255, 0.06);
            --border-glow: rgba(255, 255, 255, 0.12);
            --text-bright: #f0f0f8;
            --text-mid: #9898b8;
            --text-dim: #5a5a78;
            --accent-happy: #fbbf24;
            --accent-sad: #60a5fa;
            --accent-angry: #f43f5e;
            --accent-surprised: #fb923c;
            --accent-disgusted: #34d399;
            --accent-fearful: #a78bfa;
            --accent-neutral: #94a3b8;
            --glow-color: var(--accent-neutral);
            --radius-sm: 10px;
            --radius-md: 16px;
            --radius-lg: 24px;
            --space-xs: 6px;
            --space-sm: 10px;
            --space-md: 16px;
            --space-lg: 24px;
            --space-xl: 32px;
        }

        html { height: 100%; -webkit-text-size-adjust: 100%; }

        body {
            background: var(--bg-void);
            color: var(--text-bright);
            font-family: 'Outfit', -apple-system, BlinkMacSystemFont, sans-serif;
            min-height: 100vh;
            min-height: 100dvh;
            overflow-x: hidden;
            -webkit-font-smoothing: antialiased;
        }

        /* â”€â”€ Ambient Background â”€â”€ */
        #ambient {
            position: fixed; inset: 0; z-index: 0;
            pointer-events: none;
            overflow: hidden;
        }
        #ambient::before {
            content: '';
            position: absolute;
            width: 600px; height: 600px;
            top: -200px; left: 50%;
            transform: translateX(-50%);
            background: radial-gradient(circle, var(--glow-color) 0%, transparent 70%);
            opacity: 0.08;
            transition: opacity 0.8s ease, background 0.8s ease;
            filter: blur(80px);
        }
        #ambient::after {
            content: '';
            position: absolute;
            width: 400px; height: 400px;
            bottom: -100px; right: -100px;
            background: radial-gradient(circle, var(--accent-fearful) 0%, transparent 70%);
            opacity: 0.04;
            filter: blur(60px);
        }

        /* â”€â”€ Noise Texture Overlay â”€â”€ */
        body::after {
            content: '';
            position: fixed; inset: 0; z-index: 0;
            pointer-events: none;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)' opacity='0.03'/%3E%3C/svg%3E");
            background-repeat: repeat;
            opacity: 0.5;
        }

        /* â”€â”€ Loading Screen â”€â”€ */
        #loading-screen {
            position: fixed; inset: 0; z-index: 1000;
            background: var(--bg-void);
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            gap: 28px;
            transition: opacity 0.8s cubic-bezier(0.4, 0, 0.2, 1);
        }
        #loading-screen.fade-out { opacity: 0; pointer-events: none; }

        .loader-wrap {
            position: relative;
            width: 72px; height: 72px;
        }
        .loader-ring {
            width: 72px; height: 72px;
            border: 2px solid rgba(255,255,255,0.06);
            border-top-color: var(--accent-happy);
            border-right-color: var(--accent-surprised);
            border-radius: 50%;
            animation: spin 1.2s cubic-bezier(0.5, 0, 0.5, 1) infinite;
        }
        .loader-inner {
            position: absolute; inset: 12px;
            border: 2px solid rgba(255,255,255,0.04);
            border-bottom-color: var(--accent-sad);
            border-radius: 50%;
            animation: spin 0.8s cubic-bezier(0.5, 0, 0.5, 1) infinite reverse;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        .loading-title {
            font-size: 22px; font-weight: 700;
            letter-spacing: -0.02em;
            background: linear-gradient(135deg, var(--accent-happy) 0%, var(--accent-surprised) 50%, var(--accent-fearful) 100%);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        #loading-text {
            font-family: 'JetBrains Mono', monospace;
            color: var(--text-dim); font-size: 12px;
            letter-spacing: 0.02em;
        }
        #loading-progress {
            width: min(280px, 70vw); height: 3px;
            background: rgba(255,255,255,0.06);
            border-radius: 2px; overflow: hidden;
        }
        #loading-bar {
            height: 100%; width: 0%;
            background: linear-gradient(90deg, var(--accent-happy), var(--accent-surprised), var(--accent-fearful));
            border-radius: 2px;
            transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* â”€â”€ Error Screen â”€â”€ */
        #error-screen {
            display: none; position: fixed; inset: 0; z-index: 999;
            background: var(--bg-void);
            flex-direction: column; align-items: center; justify-content: center;
            gap: 16px; padding: 24px;
        }
        #error-screen.visible { display: flex; }
        .error-icon { font-size: 56px; }
        .error-title { font-size: 18px; font-weight: 600; }
        .error-msg {
            color: var(--text-mid); font-size: 14px;
            text-align: center; max-width: 360px; line-height: 1.7;
        }
        .retry-btn {
            margin-top: 12px; padding: 12px 32px;
            background: rgba(255,255,255,0.06); color: var(--text-bright);
            border: 1px solid var(--border-glow); border-radius: var(--radius-sm);
            cursor: pointer; font-family: 'Outfit', sans-serif;
            font-size: 14px; font-weight: 500;
            transition: all 0.25s ease;
            -webkit-tap-highlight-color: transparent;
        }
        .retry-btn:hover { background: rgba(255,255,255,0.12); transform: translateY(-1px); }
        .retry-btn:active { transform: scale(0.97); }

        /* â”€â”€ Main App â”€â”€ */
        #app {
            display: none;
            position: relative; z-index: 1;
            padding: var(--space-md);
            max-width: 1400px; margin: 0 auto;
            min-height: 100vh; min-height: 100dvh;
        }
        #app.visible { display: flex; flex-direction: column; }

        /* â”€â”€ Header â”€â”€ */
        header {
            text-align: center;
            padding: var(--space-sm) 0 var(--space-md);
            flex-shrink: 0;
        }
        header h1 {
            font-size: 20px; font-weight: 700;
            letter-spacing: -0.03em;
            background: linear-gradient(135deg, #fff 0%, var(--text-mid) 100%);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        header h1 span {
            background: linear-gradient(135deg, var(--accent-happy) 0%, var(--accent-surprised) 100%);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .subtitle {
            color: var(--text-dim); font-size: 12px;
            margin-top: 4px; font-weight: 400;
            letter-spacing: 0.02em;
        }

        /* â”€â”€ Glass Card â”€â”€ */
        .card {
            background: var(--bg-card);
            backdrop-filter: blur(24px) saturate(1.2);
            -webkit-backdrop-filter: blur(24px) saturate(1.2);
            border: 1px solid var(--border-subtle);
            border-radius: var(--radius-md);
            position: relative;
            overflow: hidden;
            transition: border-color 0.3s ease;
        }
        .card::before {
            content: '';
            position: absolute; inset: 0;
            background: linear-gradient(135deg, rgba(255,255,255,0.03) 0%, transparent 50%);
            pointer-events: none;
        }

        /* â”€â”€ Main Grid â”€â”€ */
        .main-content {
            display: flex; flex-direction: column;
            gap: var(--space-md);
            flex: 1;
        }

        /* â”€â”€ Video Section â”€â”€ */
        .video-card { padding: 0; }
        #video-wrap {
            position: relative; width: 100%;
            aspect-ratio: 4/3; overflow: hidden;
            border-radius: var(--radius-md);
            background: #000;
        }
        #video {
            width: 100%; height: 100%;
            object-fit: cover; display: block;
            transform: scaleX(-1);
        }
        #overlay {
            position: absolute; inset: 0;
            width: 100%; height: 100%;
            transform: scaleX(-1);
        }

        /* â”€â”€ Emotion HUD (overlaid on video on mobile) â”€â”€ */
        .emotion-hud-card {
            display: flex; flex-direction: column;
        }
        .emotion-hud {
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            gap: var(--space-xs);
            text-align: center;
            padding: var(--space-lg);
            flex: 1;
        }
        #emoji {
            font-size: 64px; line-height: 1;
            transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            filter: drop-shadow(0 4px 20px rgba(0,0,0,0.3));
        }
        #emoji.pulse { animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite; }
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.08); }
        }
        #emotion-label {
            font-size: 18px; font-weight: 600;
            letter-spacing: -0.01em;
            transition: color 0.4s ease;
        }
        #emotion-confidence {
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px; color: var(--text-dim);
            letter-spacing: 0.03em;
        }

        /* â”€â”€ Chart Section â”€â”€ */
        .chart-card { padding: var(--space-md); }
        .card-label {
            font-size: 11px; font-weight: 500;
            color: var(--text-dim); text-transform: uppercase;
            letter-spacing: 0.08em;
            margin-bottom: var(--space-sm);
        }
        #bar-chart-wrap { width: 100%; height: 180px; }
        #timeline-wrap { width: 100%; height: 120px; }

        /* â”€â”€ Status Bar â”€â”€ */
        .status-bar {
            display: flex; align-items: center; justify-content: space-between;
            padding: var(--space-sm) var(--space-md);
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px; color: var(--text-dim);
            flex-shrink: 0;
            margin-top: var(--space-md);
        }
        .status-left { display: flex; align-items: center; gap: 12px; flex-wrap: wrap; }
        .status-right { display: flex; align-items: center; gap: 8px; }

        .status-item { display: flex; align-items: center; gap: 6px; }
        .status-dot {
            width: 6px; height: 6px; border-radius: 50%;
            background: #22c55e; flex-shrink: 0;
        }
        .status-dot.no-face { background: #ef4444; }
        .status-dot.paused { background: #eab308; }
        .status-dot.background { animation: blink 1.4s ease-in-out infinite; background: #3b82f6; }
        @keyframes blink { 0%,100% { opacity:1; } 50% { opacity:0.2; } }

        .pause-btn {
            padding: 6px 16px; font-size: 11px;
            font-family: 'Outfit', sans-serif; font-weight: 500;
            background: rgba(255,255,255,0.06); color: var(--text-mid);
            border: 1px solid var(--border-subtle); border-radius: 6px;
            cursor: pointer; transition: all 0.2s ease;
            -webkit-tap-highlight-color: transparent;
        }
        .pause-btn:hover { background: rgba(255,255,255,0.1); color: var(--text-bright); }
        .pause-btn:active { transform: scale(0.96); }

        .backend-badge {
            padding: 3px 8px; font-size: 9px; font-weight: 600;
            font-family: 'JetBrains Mono', monospace;
            background: rgba(118, 185, 0, 0.1); color: #76b900;
            border: 1px solid rgba(118, 185, 0, 0.2);
            border-radius: 4px; text-transform: uppercase;
            letter-spacing: 0.06em;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           RESPONSIVE LAYOUT
           Mobile-first: stack everything
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

        /* â”€â”€ Mobile (< 640px) â”€â”€ */
        .sidebar { display: contents; }

        .emotion-hud { padding: var(--space-md); }
        #emoji { font-size: 56px; }
        #emotion-label { font-size: 16px; }

        #bar-chart-wrap { height: 160px; }
        #timeline-wrap { height: 100px; }

        /* â”€â”€ Tablet (640px+) â”€â”€ */
        @media (min-width: 640px) {
            #app { padding: var(--space-lg); }

            header h1 { font-size: 24px; }
            .subtitle { font-size: 13px; }

            .top-row {
                display: grid;
                grid-template-columns: 1fr;
                gap: var(--space-md);
            }

            #emoji { font-size: 64px; }
            #emotion-label { font-size: 18px; }
            #bar-chart-wrap { height: 180px; }
            #timeline-wrap { height: 120px; }
        }

        /* â”€â”€ Desktop (960px+) â”€â”€ */
        @media (min-width: 960px) {
            #app { padding: var(--space-xl); }

            header { padding: var(--space-md) 0 var(--space-lg); }
            header h1 { font-size: 26px; }

            .main-content {
                display: grid;
                grid-template-columns: 1.5fr 1fr;
                grid-template-rows: auto auto auto;
                gap: var(--space-md);
            }

            .video-card { grid-row: 1 / 3; }
            .sidebar {
                display: contents;
            }
            .emotion-hud-card { grid-column: 2; grid-row: 1; }
            .bar-chart-card { grid-column: 2; grid-row: 2; }
            .timeline-card { grid-column: 1 / -1; grid-row: 3; }

            #emoji { font-size: 72px; }
            #emotion-label { font-size: 20px; }
            .emotion-hud { min-height: 200px; }

            #bar-chart-wrap { height: 200px; }
            #timeline-wrap { height: 140px; }
        }

        /* â”€â”€ Large Desktop (1200px+) â”€â”€ */
        @media (min-width: 1200px) {
            .main-content {
                grid-template-columns: 1.6fr 1fr;
                gap: var(--space-lg);
            }

            #emoji { font-size: 80px; }
            #emotion-label { font-size: 22px; }
            #bar-chart-wrap { height: 220px; }
            #timeline-wrap { height: 160px; }

            header h1 { font-size: 28px; }
        }

        /* â”€â”€ Ultrawide (1600px+) â”€â”€ */
        @media (min-width: 1600px) {
            #app { max-width: 1600px; }
        }

        /* â”€â”€ Landscape mobile â”€â”€ */
        @media (max-height: 500px) and (orientation: landscape) {
            header { padding: 4px 0 8px; }
            header h1 { font-size: 16px; }
            .subtitle { display: none; }
            #app { padding: var(--space-sm); }

            .main-content {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: var(--space-sm);
            }

            .video-card { grid-row: 1 / 3; }
            .sidebar { display: contents; }
            .emotion-hud-card { grid-column: 2; grid-row: 1; }
            .bar-chart-card { grid-column: 2; grid-row: 2; }
            .timeline-card { grid-column: 1 / -1; }

            #video-wrap { aspect-ratio: 16/9; }
            .emotion-hud { padding: var(--space-sm); min-height: auto; }
            #emoji { font-size: 40px; }
            #emotion-label { font-size: 14px; }
            #bar-chart-wrap { height: 120px; }
            #timeline-wrap { height: 80px; }

            .status-bar { margin-top: var(--space-sm); padding: var(--space-xs) var(--space-sm); }
        }

        /* â”€â”€ Safe area (notch devices) â”€â”€ */
        @supports (padding: env(safe-area-inset-bottom)) {
            #app {
                padding-bottom: calc(var(--space-md) + env(safe-area-inset-bottom));
                padding-left: calc(var(--space-md) + env(safe-area-inset-left));
                padding-right: calc(var(--space-md) + env(safe-area-inset-right));
            }
        }

        /* â”€â”€ Hover vs Touch â”€â”€ */
        @media (hover: none) {
            .pause-btn { padding: 10px 20px; font-size: 13px; }
            .retry-btn { padding: 14px 36px; font-size: 15px; }
        }
    </style>
</head>
<body>
    <div id="ambient"></div>

    <div id="loading-screen">
        <div class="loader-wrap">
            <div class="loader-ring"></div>
            <div class="loader-inner"></div>
        </div>
        <div class="loading-title">Emotion Mirror</div>
        <div id="loading-text">WebGPU ë°±ì—”ë“œ ì´ˆê¸°í™” ì¤‘...</div>
        <div id="loading-progress"><div id="loading-bar"></div></div>
    </div>

    <div id="error-screen">
        <div class="error-icon">ğŸ“·</div>
        <div class="error-title">ì¹´ë©”ë¼ ì ‘ê·¼ í•„ìš”</div>
        <div class="error-msg" id="error-msg">
            ì´ ì•±ì€ ì›¹ìº ì„ ì‚¬ìš©í•˜ì—¬ í‘œì •ì„ ë¶„ì„í•©ë‹ˆë‹¤.<br>
            ë¸Œë¼ìš°ì €ì—ì„œ ì¹´ë©”ë¼ ì ‘ê·¼ì„ í—ˆìš©í•´ì£¼ì„¸ìš”.
        </div>
        <button class="retry-btn" id="retry-btn">ë‹¤ì‹œ ì‹œë„</button>
    </div>

    <div id="app">
        <header>
            <h1>Emotion <span>Mirror</span></h1>
            <p class="subtitle">ì‹¤ì‹œê°„ í‘œì • ê°ì • ë¶„ì„ â€” ì˜¨ë””ë°”ì´ìŠ¤ AI</p>
        </header>

        <div class="main-content">
            <div class="card video-card">
                <div id="video-wrap">
                    <video id="video" autoplay muted playsinline></video>
                    <canvas id="overlay"></canvas>
                </div>
            </div>

            <div class="sidebar">
                <div class="card emotion-hud-card">
                    <div class="emotion-hud">
                        <div id="emoji">ğŸ˜</div>
                        <div id="emotion-label" style="color: var(--accent-neutral);">Neutral</div>
                        <div id="emotion-confidence">â€” %</div>
                    </div>
                </div>

                <div class="card chart-card bar-chart-card">
                    <div class="card-label">ê°ì • ë¶„í¬</div>
                    <div id="bar-chart-wrap">
                        <canvas id="bar-chart"></canvas>
                    </div>
                </div>
            </div>

            <div class="card chart-card timeline-card">
                <div class="card-label">íƒ€ì„ë¼ì¸</div>
                <div id="timeline-wrap">
                    <canvas id="timeline-chart"></canvas>
                </div>
            </div>
        </div>

        <div class="status-bar card">
            <div class="status-left">
                <div class="status-item">
                    <span class="status-dot" id="status-dot"></span>
                    <span id="status-text">ì‹œì‘í•˜ëŠ” ì¤‘...</span>
                </div>
                <div class="status-item">
                    <span id="fps-text">0 FPS</span>
                </div>
                <span class="backend-badge" id="backend-badge">WebGPU</span>
                <div class="status-item" id="bg-indicator" style="display:none;">
                    <span class="status-dot background"></span>
                    <span>ë°±ê·¸ë¼ìš´ë“œ</span>
                </div>
            </div>
            <div class="status-right">
                <button class="pause-btn" id="pause-btn">ì¼ì‹œì •ì§€</button>
            </div>
        </div>
    </div>

    <!-- Chart.js (UMD) -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.7/dist/chart.umd.min.js"></script>

    <!-- Import map: face-api nobundleì˜ bare specifierë¥¼ esm.shë¡œ í•´ì„ -->
    <script type="importmap">
    {
        "imports": {
            "@tensorflow/tfjs/dist/index.js": "https://esm.sh/@tensorflow/tfjs@4.22.0",
            "@tensorflow/tfjs-backend-webgl/dist/index.js": "https://esm.sh/@tensorflow/tfjs-backend-webgl@4.22.0",
            "@tensorflow/tfjs-backend-wasm/dist/index.js": "https://esm.sh/@tensorflow/tfjs-backend-wasm@4.22.0"
        }
    }
    </script>

    <script type="module">
    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       Module Imports
       â€” WebGPU ë°±ì—”ë“œë¥¼ ë¡œë“œí•˜ì—¬ tfì— ë“±ë¡
       â€” face-api nobundleì€ importmapì„ í†µí•´ ë™ì¼í•œ tf ì¸ìŠ¤í„´ìŠ¤ë¥¼ ê³µìœ 
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    import 'https://esm.sh/@tensorflow/tfjs-backend-webgpu@4.22.0';
    import * as faceapi from 'https://cdn.jsdelivr.net/npm/@vladmandic/face-api@1.7.15/dist/face-api.esm-nobundle.js';
    import * as ort from 'https://esm.sh/onnxruntime-web@1.21.0/webgpu';
    ort.env.wasm.wasmPaths = 'https://cdn.jsdelivr.net/npm/onnxruntime-web@1.21.0/dist/';

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       Constants & State
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    const MODEL_URL = 'https://cdn.jsdelivr.net/npm/@vladmandic/face-api@1.7.15/model';

    const EMOTION_MAP = {
        neutral:   { emoji: 'ğŸ˜', label: 'Neutral',   color: '#94a3b8' },
        happy:     { emoji: 'ğŸ˜Š', label: 'Happy',     color: '#fbbf24' },
        sad:       { emoji: 'ğŸ˜¢', label: 'Sad',       color: '#60a5fa' },
        angry:     { emoji: 'ğŸ˜ ', label: 'Angry',     color: '#f43f5e' },
        surprised: { emoji: 'ğŸ˜²', label: 'Surprised', color: '#fb923c' },
        disgusted: { emoji: 'ğŸ¤¢', label: 'Disgusted', color: '#34d399' },
        fearful:   { emoji: 'ğŸ˜¨', label: 'Fearful',   color: '#a78bfa' },
    };

    const EMOTION_ORDER = ['happy', 'sad', 'angry', 'surprised', 'disgusted', 'fearful', 'neutral'];

    /* OpenCV FER ëª¨ë¸ ì¶œë ¥ ë¼ë²¨ (index ìˆœì„œ) */
    const OPENCV_LABELS = ['angry', 'disgusted', 'fearful', 'happy', 'neutral', 'sad', 'surprised'];

    /* 112Ã—112 ì •ë ¬ ê¸°ì¤€ì  (left eye, right eye, nose, left mouth, right mouth) */
    const REFERENCE_POINTS = [
        [38.2946, 51.6963], [73.5318, 51.5014], [56.0252, 71.7366],
        [41.5493, 92.3655], [70.7299, 92.2041],
    ];

    const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent)
        || (navigator.maxTouchPoints > 1 && window.innerWidth < 1024);

    const state = {
        isRunning: false,
        isPaused: false,
        isBackgroundMode: false,
        detectionInterval: isMobile ? 300 : 150,
        backgroundInterval: isMobile ? 1000 : 500,
        currentEmotion: 'neutral',
        currentConfidence: 0,
        currentExpressions: null,
        emotionHistory: [],
        maxHistoryLength: 300,
        historyInterval: 1000,
        lastHistorySample: 0,
        ortSession: null,
        smoothedExpressions: null,
        emaAlpha: 0.4,
        noFaceCount: 0,
        fps: 0,
        frameCount: 0,
        lastFpsUpdate: Date.now(),
    };

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       DOM References
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    const video = document.getElementById('video');
    const overlayCanvas = document.getElementById('overlay');
    const ctx = overlayCanvas.getContext('2d');
    const emojiEl = document.getElementById('emoji');
    const labelEl = document.getElementById('emotion-label');
    const confEl = document.getElementById('emotion-confidence');
    const statusDot = document.getElementById('status-dot');
    const statusText = document.getElementById('status-text');
    const fpsText = document.getElementById('fps-text');
    const bgIndicator = document.getElementById('bg-indicator');
    const pauseBtn = document.getElementById('pause-btn');
    const loadingBar = document.getElementById('loading-bar');
    const loadingTextEl = document.getElementById('loading-text');
    const ambientEl = document.getElementById('ambient');

    let barChart = null;
    let timelineChart = null;

    /* Offscreen canvas for face alignment â†’ 112Ã—112 */
    const cropCanvas = document.createElement('canvas');
    cropCanvas.width = 112;
    cropCanvas.height = 112;
    const cropCtx = cropCanvas.getContext('2d', { willReadFrequently: true });

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       Initialization
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    /* ëª¨ë°”ì¼ì—ì„œëŠ” WebGPUê°€ ë¶ˆì•ˆì •í•˜ë¯€ë¡œ WASM ì‚¬ìš© */
    const useWebGPU = !isMobile && !!navigator.gpu;

    async function init() {
        try {
            await initBackend();
            await initModels();
            await initWebcam();
            initCharts();
            initEventListeners();

            const ls = document.getElementById('loading-screen');
            ls.classList.add('fade-out');
            setTimeout(() => ls.style.display = 'none', 800);
            document.getElementById('app').classList.add('visible');
            state.isRunning = true;
            detectLoop();
        } catch (err) {
            console.error('Init failed:', err);
            document.getElementById('loading-screen').style.display = 'none';
            const errorScreen = document.getElementById('error-screen');
            const errorMsg = document.getElementById('error-msg');

            if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
                errorMsg.innerHTML = 'ì¹´ë©”ë¼ ì ‘ê·¼ì´ ê±°ë¶€ë˜ì—ˆìŠµë‹ˆë‹¤.<br>ë¸Œë¼ìš°ì € ì„¤ì •ì—ì„œ ì¹´ë©”ë¼ ê¶Œí•œì„ í—ˆìš©í•œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.';
            } else if (err.name === 'NotFoundError') {
                errorMsg.innerHTML = 'ì¹´ë©”ë¼ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.<br>ì›¹ìº ì´ ì—°ê²°ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸í•´ì£¼ì„¸ìš”.';
                document.querySelector('.error-icon').textContent = 'ğŸ”Œ';
            } else if (err.message && err.message.includes('model')) {
                errorMsg.innerHTML = 'ëª¨ë¸ ë¡œë”©ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.<br>ì¸í„°ë„· ì—°ê²°ì„ í™•ì¸í•˜ê³  ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.';
                document.querySelector('.error-icon').textContent = 'ğŸŒ';
            } else {
                errorMsg.innerHTML = `ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${err.message}`;
                document.querySelector('.error-icon').textContent = 'âš ï¸';
            }
            errorScreen.classList.add('visible');
        }
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       Backend Init (WebGPU or WASM)
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    async function initBackend() {
        const label = useWebGPU ? 'WebGPU' : 'WASM';
        loadingTextEl.textContent = `${label} ë°±ì—”ë“œ ì´ˆê¸°í™” ì¤‘...`;
        loadingBar.style.width = '5%';

        if (useWebGPU) {
            await faceapi.tf.setBackend('webgpu');
        } else {
            await faceapi.tf.setBackend('webgl');
        }
        await faceapi.tf.ready();

        const backend = faceapi.tf.getBackend();
        console.log(`TF.js backend: ${backend}`);
        document.getElementById('backend-badge').textContent = backend.toUpperCase();
    }

    async function initModels() {
        loadingTextEl.textContent = 'ì–¼êµ´ ê°ì§€ ëª¨ë¸ ë¡œë”© ì¤‘...';
        loadingBar.style.width = '10%';

        let retries = 0;
        const maxRetries = 3;

        while (retries < maxRetries) {
            try {
                await faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL);
                loadingBar.style.width = '20%';
                loadingTextEl.textContent = 'ëœë“œë§ˆí¬ ëª¨ë¸ ë¡œë”© ì¤‘...';

                await faceapi.nets.faceLandmark68TinyNet.loadFromUri(MODEL_URL);
                loadingBar.style.width = '40%';
                loadingTextEl.textContent = 'OpenCV ê°ì • ì¸ì‹ ëª¨ë¸ ë‹¤ìš´ë¡œë“œ ì¤‘...';

                /* â”€â”€ OpenCV Progressive Teacher ONNX ëª¨ë¸ (RAF-DB 88.27%) â”€â”€ */
                const ferUrl = 'https://huggingface.co/opencv/facial_expression_recognition/resolve/main/facial_expression_recognition_mobilefacenet_2022july.onnx';
                const response = await fetch(ferUrl);
                const contentLength = +(response.headers.get('Content-Length') || 0);
                const reader = response.body.getReader();
                const chunks = [];
                let received = 0;

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    chunks.push(value);
                    received += value.length;
                    if (contentLength) {
                        const pct = 40 + Math.round((received / contentLength) * 50);
                        loadingBar.style.width = pct + '%';
                    }
                    loadingTextEl.textContent = `ê°ì • ëª¨ë¸ ë‹¤ìš´ë¡œë“œ ì¤‘... ${(received / 1024).toFixed(0)} KB`;
                }

                const modelBuffer = new Uint8Array(received);
                let offset = 0;
                for (const chunk of chunks) {
                    modelBuffer.set(chunk, offset);
                    offset += chunk.length;
                }

                const ortBackend = useWebGPU ? 'webgpu' : 'wasm';
                loadingTextEl.textContent = `ONNX ì„¸ì…˜ ìƒì„± ì¤‘ (${ortBackend.toUpperCase()})...`;
                loadingBar.style.width = '92%';
                state.ortSession = await ort.InferenceSession.create(modelBuffer.buffer, {
                    executionProviders: [ortBackend],
                });
                console.log('OpenCV FER session ready:', state.ortSession.inputNames, state.ortSession.outputNames);
                loadingBar.style.width = '95%';
                loadingTextEl.textContent = 'ì¤€ë¹„ ì™„ë£Œ!';
                return;
            } catch (err) {
                retries++;
                if (retries >= maxRetries) {
                    err.message = 'model load failed after retries';
                    throw err;
                }
                loadingTextEl.textContent = `ë¡œë”© ì¬ì‹œë„ ì¤‘... (${retries}/${maxRetries})`;
                await new Promise(r => setTimeout(r, 1000 * Math.pow(2, retries)));
            }
        }
    }

    async function initWebcam() {
        loadingTextEl.textContent = 'ì¹´ë©”ë¼ ì—°ê²° ì¤‘...';
        loadingBar.style.width = '100%';
        const stream = await navigator.mediaDevices.getUserMedia({
            video: { width: { ideal: 640 }, height: { ideal: 480 }, facingMode: 'user' }
        });
        video.srcObject = stream;
        await new Promise(resolve => {
            video.onloadedmetadata = () => {
                overlayCanvas.width = video.videoWidth;
                overlayCanvas.height = video.videoHeight;
                resolve();
            };
        });
    }

    function initCharts() {
        const chartFont = { family: "'JetBrains Mono', monospace" };

        barChart = new Chart(document.getElementById('bar-chart'), {
            type: 'bar',
            data: {
                labels: EMOTION_ORDER.map(e => EMOTION_MAP[e].label),
                datasets: [{
                    data: new Array(EMOTION_ORDER.length).fill(0),
                    backgroundColor: EMOTION_ORDER.map(e => hexToRgba(EMOTION_MAP[e].color, 0.35)),
                    borderColor: EMOTION_ORDER.map(e => hexToRgba(EMOTION_MAP[e].color, 0.7)),
                    borderWidth: 1,
                    borderRadius: 4,
                    borderSkipped: false,
                }]
            },
            options: {
                indexAxis: 'y',
                responsive: true,
                maintainAspectRatio: false,
                animation: { duration: 0 },
                layout: { padding: { right: 4 } },
                scales: {
                    x: {
                        min: 0, max: 1,
                        grid: { color: 'rgba(255,255,255,0.03)', drawBorder: false },
                        ticks: { color: '#5a5a78', font: { ...chartFont, size: 10 }, callback: v => Math.round(v * 100) + '%' },
                        border: { display: false }
                    },
                    y: {
                        grid: { display: false },
                        ticks: { color: '#9898b8', font: { family: "'Outfit', sans-serif", size: 11, weight: 500 } },
                        border: { display: false }
                    }
                },
                plugins: { legend: { display: false }, tooltip: { enabled: false } }
            }
        });

        timelineChart = new Chart(document.getElementById('timeline-chart'), {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    data: [],
                    pointBackgroundColor: [],
                    borderColor: 'rgba(255,255,255,0.12)',
                    backgroundColor: 'rgba(255,255,255,0.02)',
                    fill: true,
                    tension: 0.4,
                    pointRadius: 2,
                    pointHoverRadius: 5,
                    borderWidth: 1.5,
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                layout: { padding: { right: 4 } },
                scales: {
                    x: {
                        grid: { color: 'rgba(255,255,255,0.03)', drawBorder: false },
                        ticks: { color: '#5a5a78', maxTicksLimit: 6, maxRotation: 0, font: { ...chartFont, size: 9 } },
                        border: { display: false }
                    },
                    y: {
                        min: 0, max: 1,
                        grid: { color: 'rgba(255,255,255,0.03)', drawBorder: false },
                        ticks: { color: '#5a5a78', callback: v => Math.round(v * 100) + '%', font: { ...chartFont, size: 9 } },
                        border: { display: false }
                    }
                },
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        backgroundColor: 'rgba(14, 14, 30, 0.9)',
                        borderColor: 'rgba(255,255,255,0.1)',
                        borderWidth: 1,
                        titleFont: { family: "'Outfit', sans-serif", size: 12 },
                        bodyFont: { family: "'JetBrains Mono', monospace", size: 11 },
                        cornerRadius: 8,
                        padding: 10,
                        callbacks: {
                            label: (item) => {
                                const entry = state.emotionHistory[item.dataIndex];
                                if (!entry) return '';
                                return `${EMOTION_MAP[entry.dominant].label}: ${Math.round(item.raw * 100)}%`;
                            }
                        }
                    }
                }
            }
        });
    }

    function initEventListeners() {
        document.addEventListener('visibilitychange', () => {
            state.isBackgroundMode = document.hidden;
            bgIndicator.style.display = document.hidden ? 'flex' : 'none';
            if (!document.hidden && state.currentExpressions) {
                updateBarChart(state.currentExpressions);
                updateTimeline();
            }
        });

        window.addEventListener('resize', () => {
            if (video.videoWidth) {
                overlayCanvas.width = video.videoWidth;
                overlayCanvas.height = video.videoHeight;
            }
        });

        pauseBtn.addEventListener('click', togglePause);
        document.getElementById('retry-btn').addEventListener('click', () => location.reload());
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       Detection Loop
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    async function detectLoop() {
        if (!state.isRunning) return;

        if (state.isPaused) {
            setTimeout(detectLoop, 500);
            return;
        }

        const interval = state.isBackgroundMode
            ? state.backgroundInterval
            : state.detectionInterval;

        try {
            const options = new faceapi.TinyFaceDetectorOptions({
                inputSize: isMobile ? 160 : 224,
                scoreThreshold: 0.5
            });

            const result = await faceapi.detectSingleFace(video, options)
                .withFaceLandmarks(true);

            if (result) {
                /* â”€â”€ OpenCV FER ì¶”ë¡  (landmark-aligned face) â”€â”€ */
                const inputData = alignFace(video, result.landmarks.positions);
                const inputName = state.ortSession.inputNames[0];
                const outputName = state.ortSession.outputNames[0];
                const inputTensor = new ort.Tensor('float32', inputData, [1, 3, 112, 112]);
                const output = await state.ortSession.run({ [inputName]: inputTensor });
                const logits = Array.from(output[outputName].data);
                const probs = softmax(logits);

                /* í…ì„œ ë©”ëª¨ë¦¬ í•´ì œ */
                inputTensor.dispose();
                output[outputName].dispose();

                const rawExpressions = {};
                OPENCV_LABELS.forEach((key, i) => { rawExpressions[key] = probs[i]; });
                const expressions = smoothExpressions(rawExpressions);

                state.noFaceCount = 0;
                processDetection(result, expressions);
                updateStatus('detecting');
            } else {
                state.noFaceCount++;
                if (state.noFaceCount >= 3) {
                    state.smoothedExpressions = null;
                    handleNoFace();
                    updateStatus('no-face');
                }
            }

            updateFPS();
        } catch (err) {
            console.error('Detection error:', err);
        }

        setTimeout(detectLoop, interval);
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       Process Detection
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    function processDetection(result, expressions) {
        const dims = faceapi.matchDimensions(overlayCanvas, video, true);
        const resized = faceapi.resizeResults(result, dims);

        ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

        const sorted = Object.entries(expressions).sort(([, a], [, b]) => b - a);
        const [dominant, confidence] = sorted[0];

        const emotionColor = EMOTION_MAP[dominant].color;

        drawCornerBox(resized.detection.box, emotionColor);
        drawLandmarks(resized.landmarks.positions, emotionColor);

        state.currentEmotion = dominant;
        state.currentConfidence = confidence;
        state.currentExpressions = expressions;

        updateEmojiDisplay(dominant, confidence);
        updateAmbientGlow(dominant);
        if (!state.isBackgroundMode) {
            updateBarChart(expressions);
        }

        const now = Date.now();
        if (now - state.lastHistorySample >= state.historyInterval) {
            recordHistory(expressions, dominant, confidence);
            state.lastHistorySample = now;
        }
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       Face Alignment & Preprocessing
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    function extractFivePoints(landmarks) {
        /* 68-point â†’ 5-point (left eye, right eye, nose, left mouth, right mouth) */
        const le = [0, 0], re = [0, 0];
        for (let i = 36; i <= 41; i++) { le[0] += landmarks[i].x; le[1] += landmarks[i].y; }
        for (let i = 42; i <= 47; i++) { re[0] += landmarks[i].x; re[1] += landmarks[i].y; }
        le[0] /= 6; le[1] /= 6; re[0] /= 6; re[1] /= 6;
        return [le, re, [landmarks[30].x, landmarks[30].y],
                [landmarks[48].x, landmarks[48].y], [landmarks[54].x, landmarks[54].y]];
    }

    function computeSimilarityTransform(src, dst) {
        const n = src.length;
        let sx = 0, sy = 0, dx = 0, dy = 0;
        for (let i = 0; i < n; i++) { sx += src[i][0]; sy += src[i][1]; dx += dst[i][0]; dy += dst[i][1]; }
        sx /= n; sy /= n; dx /= n; dy /= n;

        let sxx_syy = 0, sxdx_sydy = 0, sydx_sxdy = 0;
        for (let i = 0; i < n; i++) {
            const cx = src[i][0] - sx, cy = src[i][1] - sy;
            const ex = dst[i][0] - dx, ey = dst[i][1] - dy;
            sxx_syy   += cx * cx + cy * cy;
            sxdx_sydy += cx * ex + cy * ey;
            sydx_sxdy += cy * ex - cx * ey;
        }
        const a = sxdx_sydy / sxx_syy;
        const b = sydx_sxdy / sxx_syy;
        return { a, b, tx: dx - (a * sx - b * sy), ty: dy - (b * sx + a * sy) };
    }

    function alignFace(videoEl, landmarks) {
        const srcPts = extractFivePoints(landmarks);
        const { a, b, tx, ty } = computeSimilarityTransform(srcPts, REFERENCE_POINTS);

        cropCtx.save();
        cropCtx.setTransform(a, b, -b, a, tx, ty);
        cropCtx.drawImage(videoEl, 0, 0);
        cropCtx.restore();

        const { data } = cropCtx.getImageData(0, 0, 112, 112);
        /* NCHW, RGB, normalize to [-1, 1] */
        const n = 112 * 112;
        const float32 = new Float32Array(3 * n);
        for (let i = 0; i < n; i++) {
            float32[i]         = data[i * 4]     / 127.5 - 1.0;
            float32[n + i]     = data[i * 4 + 1] / 127.5 - 1.0;
            float32[2 * n + i] = data[i * 4 + 2] / 127.5 - 1.0;
        }
        return float32;
    }

    function softmax(arr) {
        const max = Math.max(...arr);
        const exps = arr.map(v => Math.exp(v - max));
        const sum = exps.reduce((a, b) => a + b, 0);
        return exps.map(v => v / sum);
    }

    function smoothExpressions(raw) {
        if (!state.smoothedExpressions) {
            state.smoothedExpressions = { ...raw };
            return state.smoothedExpressions;
        }
        const a = state.emaAlpha;
        const smoothed = {};
        for (const key of EMOTION_ORDER) {
            smoothed[key] = a * (raw[key] || 0) + (1 - a) * (state.smoothedExpressions[key] || 0);
        }
        state.smoothedExpressions = smoothed;
        return smoothed;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       Custom Drawing
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    function drawCornerBox(box, color) {
        const { x, y, width, height } = box;
        const len = Math.min(width, height) * 0.2;

        ctx.strokeStyle = color;
        ctx.lineWidth = 2.5;
        ctx.lineCap = 'round';
        ctx.shadowColor = color;
        ctx.shadowBlur = 12;

        ctx.beginPath();
        ctx.moveTo(x, y + len); ctx.lineTo(x, y); ctx.lineTo(x + len, y);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(x + width - len, y); ctx.lineTo(x + width, y); ctx.lineTo(x + width, y + len);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(x, y + height - len); ctx.lineTo(x, y + height); ctx.lineTo(x + len, y + height);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(x + width - len, y + height); ctx.lineTo(x + width, y + height); ctx.lineTo(x + width, y + height - len);
        ctx.stroke();

        ctx.shadowBlur = 0;
    }

    function drawLandmarks(positions, color) {
        ctx.fillStyle = color;
        ctx.shadowColor = color;
        ctx.shadowBlur = 4;

        for (const pt of positions) {
            ctx.beginPath();
            ctx.arc(pt.x, pt.y, 1.5, 0, Math.PI * 2);
            ctx.fill();
        }

        ctx.shadowBlur = 0;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       UI Updates
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    function updateEmojiDisplay(emotion, confidence) {
        const info = EMOTION_MAP[emotion];
        emojiEl.textContent = info.emoji;
        emojiEl.classList.toggle('pulse', confidence > 0.5);
        labelEl.textContent = info.label;
        labelEl.style.color = info.color;
        confEl.textContent = Math.round(confidence * 100) + '%';
        updateFavicon(info.emoji);
    }

    let _prevFaviconEmoji = '';
    const _faviconCanvas = document.createElement('canvas');
    _faviconCanvas.width = 64;
    _faviconCanvas.height = 64;
    const _faviconCtx = _faviconCanvas.getContext('2d');
    let _faviconLink = document.querySelector("link[rel~='icon']");
    if (!_faviconLink) {
        _faviconLink = document.createElement('link');
        _faviconLink.rel = 'icon';
        document.head.appendChild(_faviconLink);
    }

    function updateFavicon(emoji) {
        if (emoji === _prevFaviconEmoji) return;
        _prevFaviconEmoji = emoji;
        _faviconCtx.clearRect(0, 0, 64, 64);
        _faviconCtx.font = '52px serif';
        _faviconCtx.textAlign = 'center';
        _faviconCtx.textBaseline = 'middle';
        _faviconCtx.fillText(emoji, 32, 36);
        _faviconLink.href = _faviconCanvas.toDataURL('image/png');
    }

    function updateAmbientGlow(emotion) {
        const color = EMOTION_MAP[emotion]?.color || EMOTION_MAP.neutral.color;
        document.documentElement.style.setProperty('--glow-color', color);
    }

    function updateBarChart(expressions) {
        const data = EMOTION_ORDER.map(e => expressions[e] || 0);
        barChart.data.datasets[0].data = data;
        barChart.update('none');
    }

    function updateTimeline() {
        const ds = timelineChart.data;
        ds.labels = state.emotionHistory.map(h => h.time);
        ds.datasets[0].data = state.emotionHistory.map(h => h.confidence);
        ds.datasets[0].pointBackgroundColor = state.emotionHistory.map(h => EMOTION_MAP[h.dominant].color);
        timelineChart.update('none');
    }

    function handleNoFace() {
        ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
        emojiEl.textContent = 'ğŸ‘»';
        emojiEl.classList.remove('pulse');
        labelEl.textContent = 'ì–¼êµ´ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ';
        labelEl.style.color = 'var(--text-dim)';
        confEl.textContent = 'â€” %';
        updateAmbientGlow('neutral');
        updateFavicon('ğŸ‘»');
    }

    function updateStatus(mode) {
        if (mode === 'detecting') {
            statusDot.className = 'status-dot';
            statusText.textContent = 'ê°ì§€ ì¤‘';
        } else if (mode === 'no-face') {
            statusDot.className = 'status-dot no-face';
            statusText.textContent = 'ì–¼êµ´ ë¯¸ê°ì§€';
        } else if (mode === 'paused') {
            statusDot.className = 'status-dot paused';
            statusText.textContent = 'ì¼ì‹œì •ì§€';
        }
    }

    function updateFPS() {
        state.frameCount++;
        const now = Date.now();
        const elapsed = now - state.lastFpsUpdate;
        if (elapsed >= 1000) {
            state.fps = Math.round(state.frameCount * 1000 / elapsed);
            fpsText.textContent = state.fps + ' FPS';
            state.frameCount = 0;
            state.lastFpsUpdate = now;
        }
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       History
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    function recordHistory(expressions, dominant, confidence) {
        const now = new Date();
        const time = now.toLocaleTimeString('ko-KR', { hour: '2-digit', minute: '2-digit', second: '2-digit' });

        state.emotionHistory.push({ time, dominant, confidence, expressions: { ...expressions } });

        if (state.emotionHistory.length > state.maxHistoryLength) {
            state.emotionHistory.shift();
        }

        if (!state.isBackgroundMode) {
            updateTimeline();
        }
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       Controls
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    function togglePause() {
        state.isPaused = !state.isPaused;
        pauseBtn.textContent = state.isPaused ? 'ì¬ê°œ' : 'ì¼ì‹œì •ì§€';
        if (state.isPaused) {
            updateStatus('paused');
        }
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       Utilities
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    function hexToRgba(hex, alpha) {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return `rgba(${r},${g},${b},${alpha})`;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       Start
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    init();
    </script>
</body>
</html>
